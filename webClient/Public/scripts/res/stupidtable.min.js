var currentlySortedColumns = []; // maps tables ids with columns
var currentlySortingDirections = []; // maps tables ids with sorting directions

(function($) {
    $.fn.stupidtable = function(sortFns) {
        return this.each(function() {
            var $table = $(this);
            sortFns = sortFns || {};
            sortFns = $.extend({}, $.fn.stupidtable.default_sort_fns, sortFns);
            $table.data('sortFns', sortFns);

            if ($table.hasClass('fixedHeaderTable')) {
                var $headerTable = $table.closest('.fht_scroll').find('.fht_scrollHead table');
                $headerTable.on('click.stupidtable', 'thead th', function() {
                    var ths = $table.find('thead th');
                    $(ths[$(this).index()]).stupidsort();
                });
            }
            else if($table.hasClass('clusterizeTable')) {
                var $headerTable = $table.closest('.clusterize').find('.headTable');
                $headerTable.on('click.stupidtable', 'thead th', function() {
                    var ths = $table.find('thead th');
                    $(ths[$(this).index()]).stupidsort();
                });
            }
            else {
                $table.on('click.stupidtable', 'thead th', function() {
                    $(this).stupidsort();
                });
            }
        });
    };


    // Expects $("#mytable").stupidtable() to have already been called.
    // Call on a table header.
    $.fn.stupidsort = function(force_direction){
        var $this_th = $(this);
        var th_index = 0; // we'll increment this soon
        var dir = $.fn.stupidtable.dir;
        var $table = $this_th.closest("table");
        var datatype = $this_th.data("sort") || null;
        var tableId = $table.attr('id');

        currentlySortedColumns[tableId] = $this_th;

        // No datatype? Nothing to do.
        if (datatype === null) {
            return;
        }

        // Account for colspans
        $this_th.parents("tr").find("th").slice(0, $(this).index()).each(function() {
            var cols = $(this).attr("colspan") || 1;
            th_index += parseInt(cols,10);
        });

        var sort_dir;
        if(arguments.length == 1){
            sort_dir = force_direction;
        }
        else{
            sort_dir = force_direction || $this_th.data("sort-default") || dir.ASC;
            if ($this_th.data("sort-dir"))
                sort_dir = $this_th.data("sort-dir") === dir.ASC ? dir.DESC : dir.ASC;
        }

        currentlySortingDirections[tableId] = sort_dir;

        $table.trigger("beforetablesort", {column: th_index, direction: sort_dir});

        // More reliable method of forcing a redraw
        $table.css("display");

        var stupildsort_children = function(child_trs, sortMethod, sortSecondMethod) {
            var column = [];

            // Extract the data for the column that needs to be sorted and pair it up
            // with the TR itself into a tuple. This way sorting the values will
            // incidentally sort the trs.
            for (var i = 0; i < child_trs.length; i++) {
                var tr = child_trs[i];
                var $e = $(tr).children().eq(th_index);
                // data can be passed through a data-value attribute
                var dataValue = $e.attr("data-value");
                dataValue = dataValue ? dataValue : $e.text();

                var dataSecondValue = $(tr).data('value');

                column.push([dataValue, tr, dataSecondValue]);
            }

            // Sort by the data-order-by value
            column.sort(function(a, b) {
                var res = sortMethod(a[0], b[0]);

                if (res === 0 && sortSecondMethod) {
                    if (a[2] && b[2]) {
                        return res = sortSecondMethod(a[2], b[2]);
                    }
                }

                return res;
            });

            if (sort_dir != dir.ASC)
                column.reverse();

            // Replace the content of tbody with the sorted rows. Strangely
            // enough, .append accomplishes this for us.
            var sorted_child_trs = $.map(column, function(kv) { return kv[1]; });
            
            return sorted_child_trs;
        }

        // Run sorting asynchronously on a timout to force browser redraw after
        // `beforetablesort` callback. Also avoids locking up the browser too much.
        setTimeout(function() {
            // Gather the elements for this column

            var final_trs = [];
            var sortFns = $table.data('sortFns');
            var sortMethod = sortFns[datatype];
            var trs = $table.children("tbody").children("tr");

            var secondDataType = $table.data('sort');
            var sortSecondMethod = secondDataType ? sortFns[secondDataType] : null;

            var child_trs = [];
            for (var i = 0; i < trs.length; i++) {
                tr = trs[i];

                if ($(tr).hasClass('groupByHeader')) {

                    if (child_trs.length > 0) {

                        var sorted_child_trs = stupildsort_children(child_trs, sortMethod);

                        final_trs = final_trs.concat(sorted_child_trs);
                        child_trs = [];
                    }

                    final_trs.push(tr);
                }
                else {
                    child_trs.push(tr);
                }
            }

            if (child_trs.length > 0) {

                var sorted_child_trs = stupildsort_children(child_trs, sortMethod, sortSecondMethod);

                final_trs = final_trs.concat(sorted_child_trs);
            }
            
            var tbody = $table.find("tbody");
            // tbody.empty();
            tbody.append(final_trs);

            // Reset siblings
            $table.find("th").data("sort-dir", null).removeClass("sorting-desc sorting-asc");
            $this_th.data("sort-dir", sort_dir).addClass("sorting-"+sort_dir);

            $table.trigger("aftertablesort", {column: th_index, direction: sort_dir});
            $table.css("display");
        }, 10);

        return $this_th;
    };

    // Call on a sortable td to update its value in the sort. This should be the
    // only mechanism used to update a cell's sort value. If your display value is
    // different from your sort value, use jQuery's .text() or .html() to update
    // the td contents, Assumes stupidtable has already been called for the table.
    $.fn.updateSortVal = function(new_sort_val){
        var $this_td = $(this);
        if($this_td.is('[data-sort-value]')){
            // For visual consistency with the .data cache
            $this_td.attr('data-sort-value', new_sort_val);
        }
        $this_td.data("sort-value", new_sort_val);
        return $this_td;
    };

    // ------------------------------------------------------------------
    // Default settings
    // ------------------------------------------------------------------
    $.fn.stupidtable.dir = {ASC: "asc", DESC: "desc"};
    $.fn.stupidtable.default_sort_fns = {
        "int": function(a, b) {
            return parseInt(a, 10) - parseInt(b, 10);
        },
        "float": function(a, b) {
            return parseFloat(a) - parseFloat(b);
        },
        "string": function(a, b) {
            return a.localeCompare(b);
        },
        "string-ins": function(a, b) {
            a = a.toLocaleLowerCase();
            b = b.toLocaleLowerCase();
            return a.localeCompare(b);
        }
    };

    // perform a sort on the currently selected column
    $.fn.stupidRefresh = function() {
        var $this_id = $(this).attr('id');
        var sortedColumnForTable = currentlySortedColumns[$this_id];
        if (sortedColumnForTable) {
            sortedColumnForTable.stupidsort(currentlySortingDirections[$this_id]);
        }
    }
})(jQuery);